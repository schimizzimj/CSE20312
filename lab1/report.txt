Marcus Schimizzi
Lab 1 Report

To the user, the connect four game is very simple. Upon launching the game, the user is greeted with a blank game board and a prompt for player 1 to enter the column that they want to place a disc in. From there, the game switches back and forth between players and asks them to place a disc in a column until there is a winner. The program also returns an error if the user enters an invalid column, prompting the user to pick another. Upon a player winning, the program returns a congratulatory message and exits.

Internally, the program works using two classes, C4Board and C4Col. The main file is extremely simple, and only instantiates a member of the C4Board class and then calls its play() function. The C4Board class is made up of three member functions of note (two public and one private). The first function is display(), which uses nested FOR loops to print out the current board to the user. It also uses an IF statement to evaluate if the FOR loop is on the very first line, and if so, it prints column numbers to make the game more playable. The other public member function is play(), the function actually responsible for allowing players to add discs. This function uses an outer WHILE loop to allow constant play (until one player wins, of course). Inside this loop, there is another WHILE loop to ask for a player's input, and check that it is valid. It continues to prompt the user until they enter a valid input. Then, the program uses the C4Col's addDisc() function to add a disc to the board in the user's chosen column. Then, the program calls the classes's final member function of note, checkWin(), to check if a player has connected four discs in a row. If so, the victory condition is set to true and the WHILE loop stops. In the final function, checkWin(), the program checks for four discs of one type in a row. The program does this by checking for four discs vertically, horizontally, or diagonally. All three of these checks operates on essentially the same principle. It has a counter of consecutive discs found, and checks each possible direction from the last placed disc for more discs of the same type. It continues counting in a direction until it finds a spot not occupied by the correct disc. If the counter reaches 4 from a possible combination of directions (i.e. up and down or left and right), then the function returns true. 

Finally, I verified the program simply by playing all possible scenarios I could think of, and making sure it returned the expected result. I had to check that it declared a win when it was supposed to and exited at the correct time. Additionally, deconstructors are needed with dynamic memory management because they free up memory when a variable goes out of scope. If not, variable could potentially overwrite each other and in large projects, vast amounts of memory would be wasted.
