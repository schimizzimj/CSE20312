Marcus Schimizzi
2/21/17

From the user perspective, this program is exceedingly simple. The program just takes a file containing a sudoku puzzle as input and outputs the fully solved puzzle. In order to use it, the user need only run the executable with the filename as the second argument. Then, the program will process and solve the puzzle and return the fully completed sudoku.

The structure of the program involves one class, Board, and a main driver file, sudoku. The sudoku driver program is fairly barebones. It essentially is just used to obtain the file name from the user and call various member functions of an instantiated object of the Board class to process and solve the sudoku puzzle. It uses argc and argv to check if the proper number of arguments have been passed (two). If so, it instantiates an object of the board class, and then calls the read(), solve(), and print() member functions. If not, it displays a usage message to the user and returns an error code. The Board class consists of a constructor, a deconstructor, and 5 utility member functions. The class also has two private data structures. It has a 2D array of ints to store the actual values of the sudoku board. It also contains a 3D array of boolean variables used to represent the board for all potential values 1-9, showing which values are possible in each cell. A value of true (or 1) shows that that value is possible, with false showing the opposite. The constructor uses nested for loops to initialize all values in actual_board to 0, and all values in possible_board to true. The read() method function uses a WHILE loop and fstream to read in all content from the supplied file. It then puts the values in the actual_board array, and calls update to eliminate the no longer possible values from the possible_values array. The update() member function uses a mixture of FOR loops and IF statements to set all needed cells in the possible_values array to false, given an input to a certain cell. The solve() method function implements two algorithms in order to solve the puzzle, the elimination method and singleton method. The elimination method, for a given cell, checks through all layers of the possible_values array in order to see if a cell only has one possible value. If so, it sets that value and updates the arrays. The implementation of the singleton method is quite similar. However, instead of finding cells with only one true value in the possible_values array for all layers, it checks to see if the current cell is the only true cell in its row, column, and minigrid. If so, that value must be valid for that cell. The print() and print_possible() methods basically just use FOR loops to display the two arrays to the user.

The verification of the program occurred by solving the given puzzles using my program and an online sudoku solver and checking to see if they matched. At its current state, the program works to solve the three puzzles given to us. However, there were certain puzzles online (rated extremely difficult) that the program was unable to solve. 

As far as what worked well, the data structures I used made a lot of the solving pretty straightforward and simple. By having a representation of all possible values for any given cells sorted by value, row, and column, it allowed me to take a fairly simple approach to filling out empty cells. This was true especially for the elimination method, and the vertical and horizontal approach to the singleton method. For these algorithms, solving simply became iterating through a row, column, or layers and checking to see if only one of the entries had a true value. If this was the case, then that value must be valid for that cell. The only part that did not really work was the singleton approach for the minigrids. With a bit more time spent into it, I could have likely fixed it, but it was not necessary. The program still solved the given puzzles without it. 
